/* generated by yalr version 0.3.0 at 2020-11-11 12:56:44 */
#include <iostream>
#include <vector>
#include <regex>
#include <algorithm>
#include <variant>
#include <string_view>
#include <tuple>
#include <set>

#define YALR_DEBUG

/***** verbatim file.top ********/
/***** verbatim file.top ********/

#if defined(YALR_DEBUG)
#  if ! defined(YALR_LDEBUG)
#    define YALR_LDEBUG(msg) { if (debug) \
    std::cerr << msg ; }
#  endif
#  if ! defined(YALR_PDEBUG)
#    define YALR_PDEBUG(msg) { if (debug) \
    std::cerr << msg ; }
#  endif
#else
#  define YALR_LDEBUG(msg)
#  define YALR_PDEBUG(msg)
#endif

namespace YalrParser {

/***** verbatim namespace.top ********/
/***** verbatim namespace.top ********/

enum token_type {
    TOK_DottedID = 0,
    TOK_DottedIDFull = 1,
    TOK_OptionStmt = 2,
    TOK_ParserClass = 3,
    TOK_LexerClass = 4,
    TOK_Namespace = 5,
    TOK_Pattern = 6,
    TOK_Term = 7,
    TOK_Skip = 8,
    TOK_Symbol = 9,
    TOK_SymbolList = 10,
    TOK_Alt = 11,
    TOK_AltList = 12,
    TOK_Rule = 13,
    TOK_Statement = 14,
    TOK_YalrSpec = 15,
    TOK_WS = 16,
    TOK_LINECOM = 17,
    TOK_BLOCKCOM = 18,
    TOK_OPTION = 19,
    TOK_PARSER = 20,
    TOK_LEXER = 21,
    TOK_NAMESP = 22,
    TOK_CLASS = 23,
    TOK_RULE = 24,
    TOK_GOAL = 25,
    TOK_TERM = 26,
    TOK_SKIP = 27,
    TOK_ID = 28,
    TOK_ARROW = 29,
    TOK_LBRACE = 30,
    TOK_RBRACE = 31,
    TOK_SEMI = 32,
    TOK_SQUOTE = 33,
    TOK_REGEX = 34,
    TOK_TYPE = 35,
    TOK_ACTION = 36,
    TOK_0TERM1 = 37,
    TOK_YalrSpec_prime = 38,
    eoi = 39,
    undef = -1,
    skip = -10,
};

#if defined(YALR_DEBUG)
char const * const token_name[] = {

    "DottedID",
    "DottedIDFull",
    "OptionStmt",
    "ParserClass",
    "LexerClass",
    "Namespace",
    "Pattern",
    "Term",
    "Skip",
    "Symbol",
    "SymbolList",
    "Alt",
    "AltList",
    "Rule",
    "Statement",
    "YalrSpec",
    "WS",
    "LINECOM",
    "BLOCKCOM",
    "OPTION",
    "PARSER",
    "LEXER",
    "NAMESP",
    "CLASS",
    "RULE",
    "GOAL",
    "TERM",
    "SKIP",
    "ID",
    "ARROW",
    "LBRACE",
    "RBRACE",
    "SEMI",
    "SQUOTE",
    "REGEX",
    "TYPE",
    "ACTION",
    "'.'",
    "YalrSpec_prime",
    "eoi",
};
#endif

enum state_action { undefined, shift, reduce, accept, error };


using semantic_value = std::variant<
    std::monostate
    , std::string
    >;

struct value_printer {
    std::ostream& strm;
    void operator()(const std::monostate& m) {
        strm << "(void)";
    }
    void operator()(const std::string& s) {
        strm << "'" << s << "'";
    }

    template<typename T>
    void operator()(const T & t) {
        strm << t;
    }
};

struct token {
    token_type t;
    semantic_value v;

    token() {}
    token(token_type tt) : t{tt} {};
    token(token_type tt, semantic_value sv) : t{tt}, v{sv} {};
};

std::ostream& operator<<(std::ostream& strm, token t) {
#if defined(YALR_DEBUG) 
    strm << "{t=(" << t.t << "," << (t.t > -1 ? token_name[t.t] : "undef") << ") v=";
#else
    strm << "{t=" << t.t <<" v=";
#endif
    value_printer vp{strm};
    std::visit(vp, t.v);
    strm << "}";

    return strm;
}

} // namespace


namespace YalrParser {  // for the lexer

std::set<token_type> const global_patterns = {
};


struct dfa_transition_info_t {
    int state_id;
    char low;
    char high;
    int next_state;
};

constexpr std::array<dfa_transition_info_t const, 409> dfa_transitions = {{
    { 0, '\t', '\r', 1 },
    { 0, ' ', ' ', 1 },
    { 0, '\'', '\'', 73 },
    { 0, '.', '.', 85 },
    { 0, '/', '/', 2 },
    { 0, ';', ';', 65 },
    { 0, '<', '<', 78 },
    { 0, '=', '=', 61 },
    { 0, 'A', 'Z', 60 },
    { 0, '_', '_', 58 },
    { 0, 'a', 'b', 60 },
    { 0, 'c', 'c', 37 },
    { 0, 'd', 'f', 60 },
    { 0, 'g', 'g', 46 },
    { 0, 'h', 'k', 60 },
    { 0, 'l', 'l', 23 },
    { 0, 'm', 'm', 60 },
    { 0, 'n', 'n', 28 },
    { 0, 'o', 'o', 11 },
    { 0, 'p', 'p', 17 },
    { 0, 'q', 'q', 60 },
    { 0, 'r', 'r', 42 },
    { 0, 's', 's', 54 },
    { 0, 't', 't', 50 },
    { 0, 'u', 'z', 60 },
    { 0, '{', '{', 63 },
    { 0, '}', '}', 64 },
    { 1, '\t', '\r', 1 },
    { 1, ' ', ' ', 1 },
    { 2, '*', '*', 10 },
    { 2, '/', '/', 4 },
    { 3, '\0', '\t', 3 },
    { 3, '\n', '\n', 5 },
    { 3, '\v', '\x7f', 3 },
    { 4, '\0', '\t', 3 },
    { 4, '\n', '\n', 5 },
    { 4, '\v', '\x7f', 3 },
    { 6, '\0', '\t', 6 },
    { 6, '\n', '\n', 9 },
    { 6, '\v', ')', 6 },
    { 6, '*', '*', 7 },
    { 6, '+', '\x7f', 6 },
    { 7, '\0', '\t', 6 },
    { 7, '\n', '\n', 9 },
    { 7, '\v', ')', 6 },
    { 7, '*', '*', 7 },
    { 7, '+', '.', 6 },
    { 7, '/', '/', 8 },
    { 7, '0', '\x7f', 6 },
    { 8, '\0', '\t', 6 },
    { 8, '\n', '\n', 9 },
    { 8, '\v', ')', 6 },
    { 8, '*', '*', 7 },
    { 8, '+', '\x7f', 6 },
    { 9, '\0', '\t', 6 },
    { 9, '\n', '\n', 9 },
    { 9, '\v', ')', 6 },
    { 9, '*', '*', 7 },
    { 9, '+', '\x7f', 6 },
    { 10, '\0', '\t', 6 },
    { 10, '\n', '\n', 9 },
    { 10, '\v', ')', 6 },
    { 10, '*', '*', 7 },
    { 10, '+', '\x7f', 6 },
    { 11, '0', '9', 59 },
    { 11, 'A', 'Z', 59 },
    { 11, '_', '_', 59 },
    { 11, 'a', 'o', 59 },
    { 11, 'p', 'p', 12 },
    { 11, 'q', 'z', 59 },
    { 12, '0', '9', 59 },
    { 12, 'A', 'Z', 59 },
    { 12, '_', '_', 59 },
    { 12, 'a', 's', 59 },
    { 12, 't', 't', 13 },
    { 12, 'u', 'z', 59 },
    { 13, '0', '9', 59 },
    { 13, 'A', 'Z', 59 },
    { 13, '_', '_', 59 },
    { 13, 'a', 'h', 59 },
    { 13, 'i', 'i', 14 },
    { 13, 'j', 'z', 59 },
    { 14, '0', '9', 59 },
    { 14, 'A', 'Z', 59 },
    { 14, '_', '_', 59 },
    { 14, 'a', 'n', 59 },
    { 14, 'o', 'o', 15 },
    { 14, 'p', 'z', 59 },
    { 15, '0', '9', 59 },
    { 15, 'A', 'Z', 59 },
    { 15, '_', '_', 59 },
    { 15, 'a', 'm', 59 },
    { 15, 'n', 'n', 16 },
    { 15, 'o', 'z', 59 },
    { 16, '0', '9', 59 },
    { 16, 'A', 'Z', 59 },
    { 16, '_', '_', 59 },
    { 16, 'a', 'z', 59 },
    { 17, '0', '9', 59 },
    { 17, 'A', 'Z', 59 },
    { 17, '_', '_', 59 },
    { 17, 'a', 'a', 18 },
    { 17, 'b', 'z', 59 },
    { 18, '0', '9', 59 },
    { 18, 'A', 'Z', 59 },
    { 18, '_', '_', 59 },
    { 18, 'a', 'q', 59 },
    { 18, 'r', 'r', 19 },
    { 18, 's', 'z', 59 },
    { 19, '0', '9', 59 },
    { 19, 'A', 'Z', 59 },
    { 19, '_', '_', 59 },
    { 19, 'a', 'r', 59 },
    { 19, 's', 's', 20 },
    { 19, 't', 'z', 59 },
    { 20, '0', '9', 59 },
    { 20, 'A', 'Z', 59 },
    { 20, '_', '_', 59 },
    { 20, 'a', 'd', 59 },
    { 20, 'e', 'e', 21 },
    { 20, 'f', 'z', 59 },
    { 21, '0', '9', 59 },
    { 21, 'A', 'Z', 59 },
    { 21, '_', '_', 59 },
    { 21, 'a', 'q', 59 },
    { 21, 'r', 'r', 22 },
    { 21, 's', 'z', 59 },
    { 22, '0', '9', 59 },
    { 22, 'A', 'Z', 59 },
    { 22, '_', '_', 59 },
    { 22, 'a', 'z', 59 },
    { 23, '0', '9', 59 },
    { 23, 'A', 'Z', 59 },
    { 23, '_', '_', 59 },
    { 23, 'a', 'd', 59 },
    { 23, 'e', 'e', 24 },
    { 23, 'f', 'z', 59 },
    { 24, '0', '9', 59 },
    { 24, 'A', 'Z', 59 },
    { 24, '_', '_', 59 },
    { 24, 'a', 'w', 59 },
    { 24, 'x', 'x', 25 },
    { 24, 'y', 'z', 59 },
    { 25, '0', '9', 59 },
    { 25, 'A', 'Z', 59 },
    { 25, '_', '_', 59 },
    { 25, 'a', 'd', 59 },
    { 25, 'e', 'e', 26 },
    { 25, 'f', 'z', 59 },
    { 26, '0', '9', 59 },
    { 26, 'A', 'Z', 59 },
    { 26, '_', '_', 59 },
    { 26, 'a', 'q', 59 },
    { 26, 'r', 'r', 27 },
    { 26, 's', 'z', 59 },
    { 27, '0', '9', 59 },
    { 27, 'A', 'Z', 59 },
    { 27, '_', '_', 59 },
    { 27, 'a', 'z', 59 },
    { 28, '0', '9', 59 },
    { 28, 'A', 'Z', 59 },
    { 28, '_', '_', 59 },
    { 28, 'a', 'a', 29 },
    { 28, 'b', 'z', 59 },
    { 29, '0', '9', 59 },
    { 29, 'A', 'Z', 59 },
    { 29, '_', '_', 59 },
    { 29, 'a', 'l', 59 },
    { 29, 'm', 'm', 30 },
    { 29, 'n', 'z', 59 },
    { 30, '0', '9', 59 },
    { 30, 'A', 'Z', 59 },
    { 30, '_', '_', 59 },
    { 30, 'a', 'd', 59 },
    { 30, 'e', 'e', 31 },
    { 30, 'f', 'z', 59 },
    { 31, '0', '9', 59 },
    { 31, 'A', 'Z', 59 },
    { 31, '_', '_', 59 },
    { 31, 'a', 'r', 59 },
    { 31, 's', 's', 32 },
    { 31, 't', 'z', 59 },
    { 32, '0', '9', 59 },
    { 32, 'A', 'Z', 59 },
    { 32, '_', '_', 59 },
    { 32, 'a', 'o', 59 },
    { 32, 'p', 'p', 33 },
    { 32, 'q', 'z', 59 },
    { 33, '0', '9', 59 },
    { 33, 'A', 'Z', 59 },
    { 33, '_', '_', 59 },
    { 33, 'a', 'a', 34 },
    { 33, 'b', 'z', 59 },
    { 34, '0', '9', 59 },
    { 34, 'A', 'Z', 59 },
    { 34, '_', '_', 59 },
    { 34, 'a', 'b', 59 },
    { 34, 'c', 'c', 35 },
    { 34, 'd', 'z', 59 },
    { 35, '0', '9', 59 },
    { 35, 'A', 'Z', 59 },
    { 35, '_', '_', 59 },
    { 35, 'a', 'd', 59 },
    { 35, 'e', 'e', 36 },
    { 35, 'f', 'z', 59 },
    { 36, '0', '9', 59 },
    { 36, 'A', 'Z', 59 },
    { 36, '_', '_', 59 },
    { 36, 'a', 'z', 59 },
    { 37, '0', '9', 59 },
    { 37, 'A', 'Z', 59 },
    { 37, '_', '_', 59 },
    { 37, 'a', 'k', 59 },
    { 37, 'l', 'l', 38 },
    { 37, 'm', 'z', 59 },
    { 38, '0', '9', 59 },
    { 38, 'A', 'Z', 59 },
    { 38, '_', '_', 59 },
    { 38, 'a', 'a', 39 },
    { 38, 'b', 'z', 59 },
    { 39, '0', '9', 59 },
    { 39, 'A', 'Z', 59 },
    { 39, '_', '_', 59 },
    { 39, 'a', 'r', 59 },
    { 39, 's', 's', 40 },
    { 39, 't', 'z', 59 },
    { 40, '0', '9', 59 },
    { 40, 'A', 'Z', 59 },
    { 40, '_', '_', 59 },
    { 40, 'a', 'r', 59 },
    { 40, 's', 's', 41 },
    { 40, 't', 'z', 59 },
    { 41, '0', '9', 59 },
    { 41, 'A', 'Z', 59 },
    { 41, '_', '_', 59 },
    { 41, 'a', 'z', 59 },
    { 42, '0', '9', 59 },
    { 42, ':', ':', 77 },
    { 42, 'A', 'Z', 59 },
    { 42, '_', '_', 59 },
    { 42, 'a', 't', 59 },
    { 42, 'u', 'u', 43 },
    { 42, 'v', 'z', 59 },
    { 43, '0', '9', 59 },
    { 43, 'A', 'Z', 59 },
    { 43, '_', '_', 59 },
    { 43, 'a', 'k', 59 },
    { 43, 'l', 'l', 44 },
    { 43, 'm', 'z', 59 },
    { 44, '0', '9', 59 },
    { 44, 'A', 'Z', 59 },
    { 44, '_', '_', 59 },
    { 44, 'a', 'd', 59 },
    { 44, 'e', 'e', 45 },
    { 44, 'f', 'z', 59 },
    { 45, '0', '9', 59 },
    { 45, 'A', 'Z', 59 },
    { 45, '_', '_', 59 },
    { 45, 'a', 'z', 59 },
    { 46, '0', '9', 59 },
    { 46, 'A', 'Z', 59 },
    { 46, '_', '_', 59 },
    { 46, 'a', 'n', 59 },
    { 46, 'o', 'o', 47 },
    { 46, 'p', 'z', 59 },
    { 47, '0', '9', 59 },
    { 47, 'A', 'Z', 59 },
    { 47, '_', '_', 59 },
    { 47, 'a', 'a', 48 },
    { 47, 'b', 'z', 59 },
    { 48, '0', '9', 59 },
    { 48, 'A', 'Z', 59 },
    { 48, '_', '_', 59 },
    { 48, 'a', 'k', 59 },
    { 48, 'l', 'l', 49 },
    { 48, 'm', 'z', 59 },
    { 49, '0', '9', 59 },
    { 49, 'A', 'Z', 59 },
    { 49, '_', '_', 59 },
    { 49, 'a', 'z', 59 },
    { 50, '0', '9', 59 },
    { 50, 'A', 'Z', 59 },
    { 50, '_', '_', 59 },
    { 50, 'a', 'd', 59 },
    { 50, 'e', 'e', 51 },
    { 50, 'f', 'z', 59 },
    { 51, '0', '9', 59 },
    { 51, 'A', 'Z', 59 },
    { 51, '_', '_', 59 },
    { 51, 'a', 'q', 59 },
    { 51, 'r', 'r', 52 },
    { 51, 's', 'z', 59 },
    { 52, '0', '9', 59 },
    { 52, 'A', 'Z', 59 },
    { 52, '_', '_', 59 },
    { 52, 'a', 'l', 59 },
    { 52, 'm', 'm', 53 },
    { 52, 'n', 'z', 59 },
    { 53, '0', '9', 59 },
    { 53, 'A', 'Z', 59 },
    { 53, '_', '_', 59 },
    { 53, 'a', 'z', 59 },
    { 54, '0', '9', 59 },
    { 54, 'A', 'Z', 59 },
    { 54, '_', '_', 59 },
    { 54, 'a', 'j', 59 },
    { 54, 'k', 'k', 55 },
    { 54, 'l', 'z', 59 },
    { 55, '0', '9', 59 },
    { 55, 'A', 'Z', 59 },
    { 55, '_', '_', 59 },
    { 55, 'a', 'h', 59 },
    { 55, 'i', 'i', 56 },
    { 55, 'j', 'z', 59 },
    { 56, '0', '9', 59 },
    { 56, 'A', 'Z', 59 },
    { 56, '_', '_', 59 },
    { 56, 'a', 'o', 59 },
    { 56, 'p', 'p', 57 },
    { 56, 'q', 'z', 59 },
    { 57, '0', '9', 59 },
    { 57, 'A', 'Z', 59 },
    { 57, '_', '_', 59 },
    { 57, 'a', 'z', 59 },
    { 58, 'A', 'Z', 60 },
    { 58, '_', '_', 58 },
    { 58, 'a', 'z', 60 },
    { 59, '0', '9', 59 },
    { 59, 'A', 'Z', 59 },
    { 59, '_', '_', 59 },
    { 59, 'a', 'z', 59 },
    { 60, '0', '9', 59 },
    { 60, 'A', 'Z', 59 },
    { 60, '_', '_', 59 },
    { 60, 'a', 'z', 59 },
    { 61, '>', '>', 62 },
    { 66, '\0', '&', 68 },
    { 66, '\'', '\'', 75 },
    { 66, '(', '9', 68 },
    { 66, ':', ':', 67 },
    { 66, ';', '>', 68 },
    { 66, '?', '?', 66 },
    { 66, '@', '[', 68 },
    { 66, '\', '\', 71 },
    { 66, ']', '\x7f', 68 },
    { 67, '\0', '&', 68 },
    { 67, '\'', '\'', 75 },
    { 67, '(', '>', 68 },
    { 67, '?', '?', 66 },
    { 67, '@', '[', 68 },
    { 67, '\', '\', 71 },
    { 67, ']', '\x7f', 68 },
    { 68, '\0', '&', 68 },
    { 68, '\'', '\'', 75 },
    { 68, '(', '>', 68 },
    { 68, '?', '?', 66 },
    { 68, '@', '[', 68 },
    { 68, '\', '\', 71 },
    { 68, ']', '\x7f', 68 },
    { 69, '\0', '&', 68 },
    { 69, '\'', '\'', 75 },
    { 69, '(', '>', 68 },
    { 69, '?', '?', 66 },
    { 69, '@', '[', 68 },
    { 69, '\', '\', 71 },
    { 69, ']', '\x7f', 68 },
    { 70, '\'', '\'', 72 },
    { 70, '?', '?', 74 },
    { 70, '\', '\', 70 },
    { 71, '\'', '\'', 72 },
    { 71, '?', '?', 74 },
    { 71, '\', '\', 70 },
    { 72, '\'', '\'', 75 },
    { 72, '?', '?', 74 },
    { 72, '\', '\', 71 },
    { 73, '\'', '\'', 75 },
    { 73, '?', '?', 74 },
    { 74, ':', ':', 69 },
    { 76, '\0', '\b', 76 },
    { 76, '\x0e', '\x1f', 76 },
    { 76, '!', '\x7f', 76 },
    { 77, '\0', '\b', 76 },
    { 77, '\x0e', '\x1f', 76 },
    { 77, '!', '\x7f', 76 },
    { 78, '%', '%', 79 },
    { 79, '{', '{', 81 },
    { 80, '\0', '$', 80 },
    { 80, '&', '=', 80 },
    { 80, '?', '|', 80 },
    { 80, '}', '}', 82 },
    { 80, '~', '\x7f', 80 },
    { 81, '\0', '$', 80 },
    { 81, '&', '=', 80 },
    { 81, '?', '|', 80 },
    { 81, '}', '}', 82 },
    { 81, '~', '\x7f', 80 },
    { 82, '\0', '$', 80 },
    { 82, '%', '%', 83 },
    { 82, '&', '=', 80 },
    { 82, '?', '|', 80 },
    { 82, '}', '}', 82 },
    { 82, '~', '\x7f', 80 },
    { 83, '\0', '$', 80 },
    { 83, '&', '=', 80 },
    { 83, '>', '>', 84 },
    { 83, '?', '|', 80 },
    { 83, '}', '}', 82 },
    { 83, '~', '\x7f', 80 },
    { -9999, '\0', '\0', 0 },
}};

struct dfa_token_info_t {
    int state_id;
    token_type accepted;
    int rank;
};

constexpr std::array<dfa_token_info_t const, 72> dfa_token_info = {{
    { 1, token_type::skip, 53 },
    { 5, token_type::skip, 54 },
    { 8, token_type::skip, 55 },
    { 11, TOK_ID, 65 },
    { 12, TOK_ID, 65 },
    { 13, TOK_ID, 65 },
    { 14, TOK_ID, 65 },
    { 15, TOK_ID, 65 },
    { 16, TOK_OPTION, 56 },
    { 16, TOK_ID, 65 },
    { 17, TOK_ID, 65 },
    { 18, TOK_ID, 65 },
    { 19, TOK_ID, 65 },
    { 20, TOK_ID, 65 },
    { 21, TOK_ID, 65 },
    { 22, TOK_PARSER, 57 },
    { 22, TOK_ID, 65 },
    { 23, TOK_ID, 65 },
    { 24, TOK_ID, 65 },
    { 25, TOK_ID, 65 },
    { 26, TOK_ID, 65 },
    { 27, TOK_LEXER, 58 },
    { 27, TOK_ID, 65 },
    { 28, TOK_ID, 65 },
    { 29, TOK_ID, 65 },
    { 30, TOK_ID, 65 },
    { 31, TOK_ID, 65 },
    { 32, TOK_ID, 65 },
    { 33, TOK_ID, 65 },
    { 34, TOK_ID, 65 },
    { 35, TOK_ID, 65 },
    { 36, TOK_NAMESP, 59 },
    { 36, TOK_ID, 65 },
    { 37, TOK_ID, 65 },
    { 38, TOK_ID, 65 },
    { 39, TOK_ID, 65 },
    { 40, TOK_ID, 65 },
    { 41, TOK_CLASS, 60 },
    { 41, TOK_ID, 65 },
    { 42, TOK_ID, 65 },
    { 43, TOK_ID, 65 },
    { 44, TOK_ID, 65 },
    { 45, TOK_RULE, 61 },
    { 45, TOK_ID, 65 },
    { 46, TOK_ID, 65 },
    { 47, TOK_ID, 65 },
    { 48, TOK_ID, 65 },
    { 49, TOK_GOAL, 62 },
    { 49, TOK_ID, 65 },
    { 50, TOK_ID, 65 },
    { 51, TOK_ID, 65 },
    { 52, TOK_ID, 65 },
    { 53, TOK_TERM, 63 },
    { 53, TOK_ID, 65 },
    { 54, TOK_ID, 65 },
    { 55, TOK_ID, 65 },
    { 56, TOK_ID, 65 },
    { 57, TOK_SKIP, 64 },
    { 57, TOK_ID, 65 },
    { 59, TOK_ID, 65 },
    { 60, TOK_ID, 65 },
    { 62, TOK_ARROW, 66 },
    { 63, TOK_LBRACE, 67 },
    { 64, TOK_RBRACE, 68 },
    { 65, TOK_SEMI, 69 },
    { 72, TOK_SQUOTE, 70 },
    { 75, TOK_SQUOTE, 70 },
    { 76, TOK_REGEX, 71 },
    { 77, TOK_REGEX, 71 },
    { 84, TOK_ACTION, 73 },
    { 85, TOK_0TERM1, 74 },
    { -9999, token_type::undef, 0 },
}};

struct dfa_state_info_t {
    int state_id;
    int tokens;
    int transitions;
};

constexpr int dfa_start_state = 0;
constexpr std::array<dfa_state_info_t const, 86> dfa_state_info = {{
    { 0, -1, 0},
    { 1, 0, 27},
    { 2, -1, 29},
    { 3, -1, 31},
    { 4, -1, 34},
    { 5, 1, -1},
    { 6, -1, 37},
    { 7, -1, 42},
    { 8, 2, 49},
    { 9, -1, 54},
    { 10, -1, 59},
    { 11, 3, 64},
    { 12, 4, 70},
    { 13, 5, 76},
    { 14, 6, 82},
    { 15, 7, 88},
    { 16, 8, 94},
    { 17, 10, 98},
    { 18, 11, 103},
    { 19, 12, 109},
    { 20, 13, 115},
    { 21, 14, 121},
    { 22, 15, 127},
    { 23, 17, 131},
    { 24, 18, 137},
    { 25, 19, 143},
    { 26, 20, 149},
    { 27, 21, 155},
    { 28, 23, 159},
    { 29, 24, 164},
    { 30, 25, 170},
    { 31, 26, 176},
    { 32, 27, 182},
    { 33, 28, 188},
    { 34, 29, 193},
    { 35, 30, 199},
    { 36, 31, 205},
    { 37, 33, 209},
    { 38, 34, 215},
    { 39, 35, 220},
    { 40, 36, 226},
    { 41, 37, 232},
    { 42, 39, 236},
    { 43, 40, 243},
    { 44, 41, 249},
    { 45, 42, 255},
    { 46, 44, 259},
    { 47, 45, 265},
    { 48, 46, 270},
    { 49, 47, 276},
    { 50, 49, 280},
    { 51, 50, 286},
    { 52, 51, 292},
    { 53, 52, 298},
    { 54, 54, 302},
    { 55, 55, 308},
    { 56, 56, 314},
    { 57, 57, 320},
    { 58, -1, 324},
    { 59, 59, 327},
    { 60, 60, 331},
    { 61, -1, 335},
    { 62, 61, -1},
    { 63, 62, -1},
    { 64, 63, -1},
    { 65, 64, -1},
    { 66, -1, 336},
    { 67, -1, 345},
    { 68, -1, 352},
    { 69, -1, 359},
    { 70, -1, 366},
    { 71, -1, 369},
    { 72, 65, 372},
    { 73, -1, 375},
    { 74, -1, 377},
    { 75, 66, -1},
    { 76, 67, 378},
    { 77, 68, 381},
    { 78, -1, 384},
    { 79, -1, 385},
    { 80, -1, 386},
    { 81, -1, 391},
    { 82, -1, 396},
    { 83, -1, 402},
    { 84, 69, -1},
    { 85, 70, -1},
}};


template<typename IterType>
class Lexer {

public:
    using iter_type = IterType;

private:
    struct matcher {
        virtual std::pair<bool, int>
        try_match(iter_type first, const iter_type last) const = 0;

        virtual ~matcher() {}
    };

    struct regex_matcher : matcher {
        std::regex pattern;
        regex_matcher(std::string p, const std::regex_constants::syntax_option_type& opt) try : pattern{p, opt} {
            {}
        } catch (std::regex_error &e) {
            std::cerr << "Error when compiling pattern '" << p << "'\n";
            throw e;
        }
        regex_matcher(std::string p) try : pattern{p} {
            {}
        } catch (std::regex_error &e) {
            std::cerr << "Error when compiling pattern '" << p << "'\n";
            throw e;
        }
        virtual std::pair<bool, int>
        try_match(iter_type first, const iter_type last) const override {
            std::match_results<iter_type> mr;
            if (std::regex_search(first, last, mr, pattern, 
                    std::regex_constants::match_continuous)) {
                auto len = mr.length(0);
                return std::make_pair(true, len);
            } else {
                return std::make_pair(false, 0);
            }
        }
    };

    using match_ptr = const std::shared_ptr<const matcher>;

    static inline const std::array<std::tuple<match_ptr, token_type, int>, 1> patterns = {{
        { std::make_shared<regex_matcher>( R"%_^xx(<(?!%).*?>)%_^xx"   ), TOK_TYPE, 72 },
    }};

    //******************************************************************************************
    // DFA Matching algorithm
    //******************************************************************************************
    //
    struct dfa_match_results {
        token_type tt = token_type::undef;
        int rank = -1;
        int length = 0;
    };

    //**********************
    // Find a transition for the given state and input.
    // Return new state if found. Return -1 if not.
    //**********************
    int find_transition(int state_id, char input) {

        auto offset = dfa_state_info[state_id].transitions;

        // This state has no transitions
        if (offset < 0) { return -1; }

        auto ptr = &dfa_transitions[offset];

        while (ptr->state_id == state_id) {
            if (ptr->low <= input and ptr->high >= input) {
                return ptr->next_state;
            }
            ++ptr;
        }

        return -1;
    }

    // *****************************
    // ret_val.tt == undef if nothing was matched
    // retval.length will be the number of chars we looked at even 
    // for the no match state.
    //******************************
    dfa_match_results dfa_match(iter_type first, const iter_type last, 
            std::optional<std::set<token_type>> allowed_tokens) {
        dfa_match_results last_match;
        int current_state = dfa_start_state;

        while(true) {
            if (first == last) {
                YALR_LDEBUG("dfa : at eoi - bailing out\n");
                YALR_LDEBUG("dfa : returning {" << last_match.tt << ", " << last_match.length << "}\n");
                return last_match;
            }

            char current_input = *first;
            ++first;

            YALR_LDEBUG( "dfa : current_state = " << current_state <<
                " current_input = '" << current_input << "'\n");
            int new_state = find_transition(current_state, current_input);
            if (new_state == -1) {
                YALR_LDEBUG("dfa : couldn't find a transition\n");
                YALR_LDEBUG("dfa : returning {" << last_match.tt << ", " << last_match.length << "}\n");
                return last_match;
            } else {
                last_match.length += 1;
                auto const token_offset = dfa_state_info[new_state].tokens;
                if (token_offset >= 0) {
                    auto const *token_ptr = &dfa_token_info[token_offset];
                    while (token_ptr->state_id == new_state) {
                        auto tt = token_ptr->accepted;
                        YALR_LDEBUG( "dfa: new state " << new_state << " is accepting tt = " << tt << "\n");
                        if (tt == token_type::skip or not allowed_tokens or allowed_tokens->count(tt)) {
                            YALR_LDEBUG( "dfa: which IS allowed\n");
                            last_match.tt = tt;
                            last_match.rank = token_ptr->rank;
                            break;
                        } else {
                            YALR_LDEBUG( "dfa: but that isn't allowed\n");
                            ++token_ptr;
                        }
                    }

                } else {
                    YALR_LDEBUG("dfa: new state " << new_state << " is NOT accepting\n");
                }

            }
            current_state = new_state;
        }

    }

/***** verbatim lexer.top ********/
/***** verbatim lexer.top ********/
public:
#if defined(YALR_DEBUG)
    bool debug = false;
#endif
    Lexer(iter_type first, const iter_type last) :
        current(first), last(last) {
    }

    virtual token next_token( std::optional<std::set<token_type>> allowed_tokens = std::nullopt) {
        if (current == last) {
            YALR_LDEBUG( "Returning token eoi\n");
            return eoi;
        }

        if (allowed_tokens) {
            allowed_tokens->insert(global_patterns.begin(), global_patterns.end());
        }

        token_type ret_type = undef;
        std::size_t max_len = 0;
        int current_match_rank = -1;
#if defined(YALR_DEBUG)
        if (debug) {
            std::cerr << "lexer: Next few characters: " ;
            auto ptr = current;
            for (int i =0 ; i < 10 && ptr != last; ++i) {
                std::cerr << *ptr;
                ++ptr;
            }
            std::cerr << "\n";

            std::cerr << "lexer: Trying the dfa\n";
        }

#endif

        auto dfa_res = dfa_match(current, last, allowed_tokens);

        if (dfa_res.tt != token_type::undef) {
            ret_type = dfa_res.tt;
            max_len = dfa_res.length;
            current_match_rank = dfa_res.rank;
            YALR_LDEBUG( "lexer: dfa matched for tt = " << ret_type << " length = " << max_len << "\n");
        } else {
            YALR_LDEBUG( "lexer: no dfa match\n");
        }

        for (const auto &[m, tt, rank] : patterns) {
            // if there is a token restriction and we're not on the include list,
            // skip.
            if (allowed_tokens and allowed_tokens->count(tt) == 0) {
                continue;
            }
            YALR_LDEBUG("lexer: Matching for token # " << tt << " rank = " << rank << "\n");
            auto [matched, len] = m->try_match(current, last);
            if (matched) {
                YALR_LDEBUG(" length = " << len << "\n");
                // Override for the same length match if the single matchers came earlier than the dfa match
                if ( std::size_t(len) > max_len or (std::size_t(len) == max_len and rank < current_match_rank)) {
                    max_len = len;
                    ret_type = tt;
                    current_match_rank = rank;
                }
            } else {
                YALR_LDEBUG(" - no match\n");
            }
        }
        if (max_len == 0) {
            current = last;
            return token{undef};
        } else if (ret_type == skip) {
            YALR_LDEBUG("lexer: recursing due to skip\n");
            current += max_len;
            return next_token(allowed_tokens);
        }
        std::string lx{current, current+max_len};
        semantic_value ret_sval;
        switch (ret_type) {
            case TOK_ID : {
                    auto block = [](std::string&& lexeme) -> std::string
                    {   return std::move(lexeme);  };
                    ret_sval = block(std::move(lx));
                }
                break;
            case TOK_SQUOTE : {
                    auto block = [](std::string&& lexeme) -> std::string
                    {   return std::move(lexeme);  };
                    ret_sval = block(std::move(lx));
                }
                break;
            case TOK_REGEX : {
                    auto block = [](std::string&& lexeme) -> std::string
                    {   return std::move(lexeme);  };
                    ret_sval = block(std::move(lx));
                }
                break;
            case TOK_TYPE : {
                    auto block = [](std::string&& lexeme) -> std::string
                    {   return lexeme.substr(1, lexeme.size()-2);  };
                    ret_sval = block(std::move(lx));
                }
                break;
            case TOK_ACTION : {
                    auto block = [](std::string&& lexeme) -> std::string
                    {   return lexeme.substr(3, lexeme.size()-4);  };
                    ret_sval = block(std::move(lx));
                }
                break;
            default :
                /* do nothing */
                break;
        }

        if (debug) {
            std::string lx{current, current+max_len};
            YALR_LDEBUG( "lexer: Returning token = " << ret_type);
            if (ret_type >= 0) {
                YALR_LDEBUG(" (" << token_name[ret_type] << ")")
            }
            YALR_LDEBUG (" lex={" << lx << "}\n");
        }
        current += max_len;
        return token{ret_type, ret_sval};
    }

    // Just needed to make it virtual
    virtual ~Lexer() = default;
private:
    iter_type current;
    const iter_type last;

/***** verbatim lexer.bottom ********/
/***** verbatim lexer.bottom ********/
};

} // namespace YalrParser




namespace YalrParser {  // for the parser

template<typename LexerClass>
class Parser {
public:
    using lexer_class = LexerClass;

private:
    lexer_class& lexer;
    token la;
    int current_state;

    struct parse_stack_entry {
        token tv;
        int         state;
    };

    std::deque<parse_stack_entry> tokstack;

    void printstack() {
        std::cerr << "(st=" << current_state << ")[la= " << la << "]" ;
        for (const auto& x : tokstack) {
            std::cerr << " (" << x.tv;
            std::cerr << ",s=" << x.state;
            std::cerr << ")";
        }
        std::cerr << "\n";
    }

/***** verbatim parser.top start ********/
/***** verbatim parser.top end ********/

/************** reduce functions *****************/
    // A reduce function pointer
    // Returns a semantic value
    using reduce_func_ptr = parse_stack_entry (Parser::*)();

    parse_stack_entry reduce_by_prod0() {
        YALR_PDEBUG( "Reducing by : [0] DottedID(22) => ID(65) '.'(74) ID(65)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v1 = std::get<std::string>(tokstack.back().tv.v); 
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_DottedID, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod1() {
        YALR_PDEBUG( "Reducing by : [1] DottedIDFull(24) => DottedID(22)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_DottedIDFull, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod2() {
        YALR_PDEBUG( "Reducing by : [2] DottedIDFull(24) => DottedID(22) '.'(74) ID(65)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_DottedIDFull, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod3() {
        YALR_PDEBUG( "Reducing by : [3] OptionStmt(26) => OPTION(56) DottedID(22) ID(65) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_OptionStmt, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod4() {
        YALR_PDEBUG( "Reducing by : [4] ParserClass(28) => PARSER(57) CLASS(60) ID(65) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_ParserClass, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod5() {
        YALR_PDEBUG( "Reducing by : [5] LexerClass(30) => LEXER(58) CLASS(60) ID(65) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_LexerClass, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod6() {
        YALR_PDEBUG( "Reducing by : [6] Namespace(32) => NAMESP(59) ID(65) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Namespace, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod7() {
        YALR_PDEBUG( "Reducing by : [7] Pattern(34) => SQUOTE(70)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v1 = std::get<std::string>(tokstack.back().tv.v); 
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Pattern, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod8() {
        YALR_PDEBUG( "Reducing by : [8] Pattern(34) => REGEX(71)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v1 = std::get<std::string>(tokstack.back().tv.v); 
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Pattern, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod9() {
        YALR_PDEBUG( "Reducing by : [9] Term(36) => TERM(63) ID(65) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Term, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod10() {
        YALR_PDEBUG( "Reducing by : [10] Term(36) => TERM(63) ID(65) Pattern(34) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Term, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod11() {
        YALR_PDEBUG( "Reducing by : [11] Term(36) => TERM(63) TYPE(72) ID(65) Pattern(34) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Term, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod12() {
        YALR_PDEBUG( "Reducing by : [12] Term(36) => TERM(63) TYPE(72) ID(65) Pattern(34) ACTION(73)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v5 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Term, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod13() {
        YALR_PDEBUG( "Reducing by : [13] Skip(38) => SKIP(64) ID(65) Pattern(34) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Skip, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod14() {
        YALR_PDEBUG( "Reducing by : [14] Symbol(40) => ID(65)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v1 = std::get<std::string>(tokstack.back().tv.v); 
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Symbol, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod15() {
        YALR_PDEBUG( "Reducing by : [15] Symbol(40) => SQUOTE(70)\n");
        parse_stack_entry retval;
        semantic_value sv;

        auto _v1 = std::get<std::string>(tokstack.back().tv.v); 
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Symbol, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod16() {
        YALR_PDEBUG( "Reducing by : [16] SymbolList(42) => SymbolList(42) Symbol(40)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_SymbolList, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod17() {
        YALR_PDEBUG( "Reducing by : [17] SymbolList(42) =>\n");
        parse_stack_entry retval;
        semantic_value sv;

        retval.state = current_state; 

        retval.tv = { TOK_SymbolList, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod18() {
        YALR_PDEBUG( "Reducing by : [18] Alt(44) => ARROW(66) SymbolList(42) SEMI(69)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Alt, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod19() {
        YALR_PDEBUG( "Reducing by : [19] AltList(46) => Alt(44)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_AltList, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod20() {
        YALR_PDEBUG( "Reducing by : [20] AltList(46) => AltList(46) Alt(44)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_AltList, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod21() {
        YALR_PDEBUG( "Reducing by : [21] Rule(48) => GOAL(62) RULE(61) TYPE(72) ID(65) LBRACE(67) AltList(46) RBRACE(68)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v4 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Rule, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod22() {
        YALR_PDEBUG( "Reducing by : [22] Rule(48) => GOAL(62) RULE(61) ID(65) LBRACE(67) AltList(46) RBRACE(68)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Rule, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod23() {
        YALR_PDEBUG( "Reducing by : [23] Rule(48) => RULE(61) TYPE(72) ID(65) LBRACE(67) AltList(46) RBRACE(68)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v3 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Rule, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod24() {
        YALR_PDEBUG( "Reducing by : [24] Rule(48) => RULE(61) ID(65) LBRACE(67) AltList(46) RBRACE(68)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        
        tokstack.pop_back();

        auto _v2 = std::get<std::string>(tokstack.back().tv.v); 
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Rule, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod25() {
        YALR_PDEBUG( "Reducing by : [25] Statement(50) => Namespace(32)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod26() {
        YALR_PDEBUG( "Reducing by : [26] Statement(50) => ParserClass(28)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod27() {
        YALR_PDEBUG( "Reducing by : [27] Statement(50) => LexerClass(30)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod28() {
        YALR_PDEBUG( "Reducing by : [28] Statement(50) => Skip(38)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod29() {
        YALR_PDEBUG( "Reducing by : [29] Statement(50) => Term(36)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod30() {
        YALR_PDEBUG( "Reducing by : [30] Statement(50) => Rule(48)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod31() {
        YALR_PDEBUG( "Reducing by : [31] Statement(50) => OptionStmt(26)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_Statement, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod32() {
        YALR_PDEBUG( "Reducing by : [32] YalrSpec(52) => Statement(50)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_YalrSpec, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod33() {
        YALR_PDEBUG( "Reducing by : [33] YalrSpec(52) => YalrSpec(52) Statement(50)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        tokstack.pop_back();

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_YalrSpec, sv};
        return retval;
    }
    parse_stack_entry reduce_by_prod34() {
        YALR_PDEBUG( "Reducing by : [34] YalrSpec_prime(75) => YalrSpec(52)\n");
        parse_stack_entry retval;
        semantic_value sv;

        
        retval = tokstack.back(); 
        tokstack.pop_back();

        

        retval.tv = { TOK_YalrSpec_prime, sv};
        return retval;
    }
/************** end reduce functions *****************/

/************* parser table *************************/

    struct action_entry {
        // Our current state
        int state_id;
        //  What we just saw. This will only be a true terminal.
        token_type toktype;
        // What we should do
        state_action act_type;
        // shift vars
        int new_state_id;
        // reduce vars
        reduce_func_ptr reduce_func;
    };

    static constexpr action_entry const action_error_entry = {0, token_type::undef, state_action::error, 0, nullptr };


    static inline std::vector<action_entry> state_table = {
        { 0 , TOK_OPTION , state_action::shift , 10, nullptr},
        { 0 , TOK_PARSER , state_action::shift , 11, nullptr},
        { 0 , TOK_LEXER , state_action::shift , 12, nullptr},
        { 0 , TOK_NAMESP , state_action::shift , 13, nullptr},
        { 0 , TOK_RULE , state_action::shift , 14, nullptr},
        { 0 , TOK_GOAL , state_action::shift , 15, nullptr},
        { 0 , TOK_TERM , state_action::shift , 16, nullptr},
        { 0 , TOK_SKIP , state_action::shift , 17, nullptr},
        { 1, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 1, eoi, state_action::reduce, 0, &Parser::reduce_by_prod31},
        { 2, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 2, eoi, state_action::reduce, 0, &Parser::reduce_by_prod26},
        { 3, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 3, eoi, state_action::reduce, 0, &Parser::reduce_by_prod27},
        { 4, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 4, eoi, state_action::reduce, 0, &Parser::reduce_by_prod25},
        { 5, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 5, eoi, state_action::reduce, 0, &Parser::reduce_by_prod29},
        { 6, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 6, eoi, state_action::reduce, 0, &Parser::reduce_by_prod28},
        { 7, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 7, eoi, state_action::reduce, 0, &Parser::reduce_by_prod30},
        { 8, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 8, eoi, state_action::reduce, 0, &Parser::reduce_by_prod32},
        { 9 , TOK_OPTION , state_action::shift , 10, nullptr},
        { 9 , TOK_PARSER , state_action::shift , 11, nullptr},
        { 9 , TOK_LEXER , state_action::shift , 12, nullptr},
        { 9 , TOK_NAMESP , state_action::shift , 13, nullptr},
        { 9 , TOK_RULE , state_action::shift , 14, nullptr},
        { 9 , TOK_GOAL , state_action::shift , 15, nullptr},
        { 9 , TOK_TERM , state_action::shift , 16, nullptr},
        { 9 , TOK_SKIP , state_action::shift , 17, nullptr},
        { 9 , eoi , state_action::accept, 0, nullptr },
        { 10 , TOK_ID , state_action::shift , 20, nullptr},
        { 11 , TOK_CLASS , state_action::shift , 21, nullptr},
        { 12 , TOK_CLASS , state_action::shift , 22, nullptr},
        { 13 , TOK_ID , state_action::shift , 23, nullptr},
        { 14 , TOK_ID , state_action::shift , 24, nullptr},
        { 14 , TOK_TYPE , state_action::shift , 25, nullptr},
        { 15 , TOK_RULE , state_action::shift , 26, nullptr},
        { 16 , TOK_ID , state_action::shift , 27, nullptr},
        { 16 , TOK_TYPE , state_action::shift , 28, nullptr},
        { 17 , TOK_ID , state_action::shift , 29, nullptr},
        { 18, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 18, eoi, state_action::reduce, 0, &Parser::reduce_by_prod33},
        { 19 , TOK_ID , state_action::shift , 30, nullptr},
        { 20 , TOK_0TERM1 , state_action::shift , 31, nullptr},
        { 21 , TOK_ID , state_action::shift , 32, nullptr},
        { 22 , TOK_ID , state_action::shift , 33, nullptr},
        { 23 , TOK_SEMI , state_action::shift , 34, nullptr},
        { 24 , TOK_LBRACE , state_action::shift , 35, nullptr},
        { 25 , TOK_ID , state_action::shift , 36, nullptr},
        { 26 , TOK_ID , state_action::shift , 37, nullptr},
        { 26 , TOK_TYPE , state_action::shift , 38, nullptr},
        { 27 , TOK_SEMI , state_action::shift , 40, nullptr},
        { 27 , TOK_SQUOTE , state_action::shift , 41, nullptr},
        { 27 , TOK_REGEX , state_action::shift , 42, nullptr},
        { 28 , TOK_ID , state_action::shift , 43, nullptr},
        { 29 , TOK_SQUOTE , state_action::shift , 41, nullptr},
        { 29 , TOK_REGEX , state_action::shift , 42, nullptr},
        { 30 , TOK_SEMI , state_action::shift , 45, nullptr},
        { 31 , TOK_ID , state_action::shift , 46, nullptr},
        { 32 , TOK_SEMI , state_action::shift , 47, nullptr},
        { 33 , TOK_SEMI , state_action::shift , 48, nullptr},
        { 34, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 34, eoi, state_action::reduce, 0, &Parser::reduce_by_prod6},
        { 35 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 36 , TOK_LBRACE , state_action::shift , 52, nullptr},
        { 37 , TOK_LBRACE , state_action::shift , 53, nullptr},
        { 38 , TOK_ID , state_action::shift , 54, nullptr},
        { 39 , TOK_SEMI , state_action::shift , 55, nullptr},
        { 40, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 40, eoi, state_action::reduce, 0, &Parser::reduce_by_prod9},
        { 41, TOK_SEMI, state_action::reduce, 0, &Parser::reduce_by_prod7},
        { 41, TOK_ACTION, state_action::reduce, 0, &Parser::reduce_by_prod7},
        { 42, TOK_SEMI, state_action::reduce, 0, &Parser::reduce_by_prod8},
        { 42, TOK_ACTION, state_action::reduce, 0, &Parser::reduce_by_prod8},
        { 43 , TOK_SQUOTE , state_action::shift , 41, nullptr},
        { 43 , TOK_REGEX , state_action::shift , 42, nullptr},
        { 44 , TOK_SEMI , state_action::shift , 57, nullptr},
        { 45, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 45, eoi, state_action::reduce, 0, &Parser::reduce_by_prod3},
        { 46, TOK_ID, state_action::reduce, 0, &Parser::reduce_by_prod0},
        { 46, TOK_0TERM1, state_action::reduce, 0, &Parser::reduce_by_prod0},
        { 47, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 47, eoi, state_action::reduce, 0, &Parser::reduce_by_prod4},
        { 48, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 48, eoi, state_action::reduce, 0, &Parser::reduce_by_prod5},
        { 49, TOK_ARROW, state_action::reduce, 0, &Parser::reduce_by_prod19},
        { 49, TOK_RBRACE, state_action::reduce, 0, &Parser::reduce_by_prod19},
        { 50 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 50 , TOK_RBRACE , state_action::shift , 59, nullptr},
        { 51, TOK_ID, state_action::reduce, 0, &Parser::reduce_by_prod17},
        { 51, TOK_SEMI, state_action::reduce, 0, &Parser::reduce_by_prod17},
        { 51, TOK_SQUOTE, state_action::reduce, 0, &Parser::reduce_by_prod17},
        { 52 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 53 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 54 , TOK_LBRACE , state_action::shift , 63, nullptr},
        { 55, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 55, eoi, state_action::reduce, 0, &Parser::reduce_by_prod10},
        { 56 , TOK_SEMI , state_action::shift , 64, nullptr},
        { 56 , TOK_ACTION , state_action::shift , 65, nullptr},
        { 57, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 57, eoi, state_action::reduce, 0, &Parser::reduce_by_prod13},
        { 58, TOK_ARROW, state_action::reduce, 0, &Parser::reduce_by_prod20},
        { 58, TOK_RBRACE, state_action::reduce, 0, &Parser::reduce_by_prod20},
        { 59, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 59, eoi, state_action::reduce, 0, &Parser::reduce_by_prod24},
        { 60 , TOK_ID , state_action::shift , 67, nullptr},
        { 60 , TOK_SEMI , state_action::shift , 68, nullptr},
        { 60 , TOK_SQUOTE , state_action::shift , 69, nullptr},
        { 61 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 61 , TOK_RBRACE , state_action::shift , 70, nullptr},
        { 62 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 62 , TOK_RBRACE , state_action::shift , 71, nullptr},
        { 63 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 64, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 64, eoi, state_action::reduce, 0, &Parser::reduce_by_prod11},
        { 65, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 65, eoi, state_action::reduce, 0, &Parser::reduce_by_prod12},
        { 66, TOK_ID, state_action::reduce, 0, &Parser::reduce_by_prod16},
        { 66, TOK_SEMI, state_action::reduce, 0, &Parser::reduce_by_prod16},
        { 66, TOK_SQUOTE, state_action::reduce, 0, &Parser::reduce_by_prod16},
        { 67, TOK_ID, state_action::reduce, 0, &Parser::reduce_by_prod14},
        { 67, TOK_SEMI, state_action::reduce, 0, &Parser::reduce_by_prod14},
        { 67, TOK_SQUOTE, state_action::reduce, 0, &Parser::reduce_by_prod14},
        { 68, TOK_ARROW, state_action::reduce, 0, &Parser::reduce_by_prod18},
        { 68, TOK_RBRACE, state_action::reduce, 0, &Parser::reduce_by_prod18},
        { 69, TOK_ID, state_action::reduce, 0, &Parser::reduce_by_prod15},
        { 69, TOK_SEMI, state_action::reduce, 0, &Parser::reduce_by_prod15},
        { 69, TOK_SQUOTE, state_action::reduce, 0, &Parser::reduce_by_prod15},
        { 70, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 70, eoi, state_action::reduce, 0, &Parser::reduce_by_prod23},
        { 71, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 71, eoi, state_action::reduce, 0, &Parser::reduce_by_prod22},
        { 72 , TOK_ARROW , state_action::shift , 51, nullptr},
        { 72 , TOK_RBRACE , state_action::shift , 73, nullptr},
        { 73, TOK_OPTION, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_PARSER, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_LEXER, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_NAMESP, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_RULE, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_GOAL, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_TERM, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, TOK_SKIP, state_action::reduce, 0, &Parser::reduce_by_prod21},
        { 73, eoi, state_action::reduce, 0, &Parser::reduce_by_prod21},
    };

    const action_entry &find_action(int state, token_type tt) {
        // binary search
        int bottom = 0;
        int top = state_table.size()-1;
            
        while(true) {
            if (top < bottom) {
                return action_error_entry;
            } else if (top == bottom) {
                if (state_table[top].state_id == state and state_table[top].toktype == tt) {
                    return state_table[top];
                } else {
                    return action_error_entry;
                }
            } else { // top > bottom 
                int index = (top+bottom)/2; // integer math
                auto &current = state_table[index];
                if ( state > current.state_id or (state == current.state_id and tt > current.toktype)) {
                    // index will equal bottom if top and bottom are 1 apart.
                    if (index == bottom) {
                        bottom += 1;
                    } else {
                        bottom = index;
                    }
                } else if (state == current.state_id and tt == current.toktype) {
                    // we hit pay dirt
                    return current;
                } else { // key is < suspect. look in lower half.
                    // integer math above ensures that, if we get here,
                    // index will be strictly less than top.
                    top = index;
                }
            }

        } /// while

        // should never get here. but just to make sure.
        // probably should be an assert.
        return action_error_entry;
    }

    struct goto_entry {
        int state_id;
        token_type toktype;
        int new_state_id;
    };

    std::vector<goto_entry> goto_table {
        { 0, TOK_OptionStmt, 1 },
        { 0, TOK_ParserClass, 2 },
        { 0, TOK_LexerClass, 3 },
        { 0, TOK_Namespace, 4 },
        { 0, TOK_Term, 5 },
        { 0, TOK_Skip, 6 },
        { 0, TOK_Rule, 7 },
        { 0, TOK_Statement, 8 },
        { 0, TOK_YalrSpec, 9 },
        { 9, TOK_OptionStmt, 1 },
        { 9, TOK_ParserClass, 2 },
        { 9, TOK_LexerClass, 3 },
        { 9, TOK_Namespace, 4 },
        { 9, TOK_Term, 5 },
        { 9, TOK_Skip, 6 },
        { 9, TOK_Rule, 7 },
        { 9, TOK_Statement, 18 },
        { 10, TOK_DottedID, 19 },
        { 27, TOK_Pattern, 39 },
        { 29, TOK_Pattern, 44 },
        { 35, TOK_Alt, 49 },
        { 35, TOK_AltList, 50 },
        { 43, TOK_Pattern, 56 },
        { 50, TOK_Alt, 58 },
        { 51, TOK_SymbolList, 60 },
        { 52, TOK_Alt, 49 },
        { 52, TOK_AltList, 61 },
        { 53, TOK_Alt, 49 },
        { 53, TOK_AltList, 62 },
        { 60, TOK_Symbol, 66 },
        { 61, TOK_Alt, 58 },
        { 62, TOK_Alt, 58 },
        { 63, TOK_Alt, 49 },
        { 63, TOK_AltList, 72 },
        { 72, TOK_Alt, 58 },
    };

    int find_goto(int state, token_type tt) {
        // binary search
        int bottom = 0;
        int top = goto_table.size()-1;
            
        while(true) {
            if (top < bottom) {
                return -1;
            } else if (top == bottom) {
                if (goto_table[top].state_id == state and goto_table[top].toktype == tt) {
                    return goto_table[top].new_state_id;
                } else {
                    return -1;
                }
            } else { // top > bottom 
                int index = (top+bottom)/2; // integer math
                auto &current = goto_table[index];
                if ( state > current.state_id or (state == current.state_id and tt > current.toktype)) {
                    // index will equal bottom if top and bottom are 1 apart.
                    if (index == bottom) {
                        bottom += 1;
                    } else {
                        bottom = index;
                    }
                } else if (state == current.state_id and tt == current.toktype) {
                    // we hit pay dirt
                    return current.new_state_id;
                } else { // key is < suspect. look in lower half.
                    // integer math above ensures that, if we get here,
                    // index will be strictly less than top.
                    top = index;
                }
            }

        } /// while

        // should never get here. but just to make sure.
        // probably should be an assert.
        return -1;
    }

    std::vector<std::set<token_type>> valid_terms = {
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_CLASS, 
        },
        {
            TOK_CLASS, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_ID, TOK_TYPE, 
        },
        {
            TOK_RULE, 
        },
        {
            TOK_ID, TOK_TYPE, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_0TERM1, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_SEMI, 
        },
        {
            TOK_LBRACE, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_ID, TOK_TYPE, 
        },
        {
            TOK_SEMI, TOK_SQUOTE, TOK_REGEX, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_SQUOTE, TOK_REGEX, 
        },
        {
            TOK_SEMI, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_SEMI, 
        },
        {
            TOK_SEMI, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ARROW, 
        },
        {
            TOK_LBRACE, 
        },
        {
            TOK_LBRACE, 
        },
        {
            TOK_ID, 
        },
        {
            TOK_SEMI, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_SEMI, TOK_ACTION, 
        },
        {
            TOK_SEMI, TOK_ACTION, 
        },
        {
            TOK_SQUOTE, TOK_REGEX, 
        },
        {
            TOK_SEMI, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ID, TOK_0TERM1, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_ID, TOK_SEMI, TOK_SQUOTE, 
        },
        {
            TOK_ARROW, 
        },
        {
            TOK_ARROW, 
        },
        {
            TOK_LBRACE, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_SEMI, TOK_ACTION, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ID, TOK_SEMI, TOK_SQUOTE, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_ARROW, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ID, TOK_SEMI, TOK_SQUOTE, 
        },
        {
            TOK_ID, TOK_SEMI, TOK_SQUOTE, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_ID, TOK_SEMI, TOK_SQUOTE, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
        {
            TOK_ARROW, TOK_RBRACE, 
        },
        {
            TOK_OPTION, TOK_PARSER, TOK_LEXER, TOK_NAMESP, TOK_RULE, TOK_GOAL, TOK_TERM, TOK_SKIP, eoi, 
        },
    };

public:
#if defined(YALR_DEBUG)
    bool debug = false;
#endif
    Parser(lexer_class& l) : lexer(l){};

    bool doparse() {
        current_state = 0;
        la = lexer.next_token(valid_terms[current_state]);
        bool done = false;
        while(not done) {
#if defined(YALR_DEBUG)
            if (debug) printstack();
#endif
            auto action = find_action(current_state, la.t);
            switch(action.act_type) {
                case state_action::accept :
                    YALR_PDEBUG("$$$$$$$ Accepting $$$$\n");
                    return true;
                case state_action::shift :
                    YALR_PDEBUG("shifting and going to state " << action.new_state_id << "\n");
                    tokstack.push_back({la, current_state});
                    current_state = action.new_state_id;
                    la = lexer.next_token(valid_terms[current_state]);
                    break;
                case state_action::reduce :
                    {
                    auto pse = std::invoke(action.reduce_func, *this);
                    auto new_state = find_goto(pse.state, pse.tv.t);
                    YALR_PDEBUG("Goto - old state = " <<pse.state <<" new state = " << new_state << "\n");
                    tokstack.push_back(pse);
                    current_state = new_state;
                    }
                    break;
                default:
                    YALR_PDEBUG("!!!!! ERROR !!!!");
                    return false;
            }
        }

        return false;
    }

/***** verbatim parser.bottom start ********/
/***** verbatim parser.bottom end ********/

}; // class Parser


} // namespace YalrParser



namespace YalrParser {
/***** verbatim namespace.bottom start ********/
/***** verbatim namespace.bottom end ********/

} // namespace YalrParser

/***** verbatim file.bottom start ********/
/***** verbatim file.bottom end ********/


#include <string>
#include <fstream>

int main(int argc, char*argv[]) {

    int current_arg = 1;
    bool parser_debug = false;
    bool lexer_debug = false;
    bool input_is_file = false;
    std::string input = "";

    while (argc > current_arg) {

       if (std::string("-p").compare(argv[current_arg]) == 0) {
            parser_debug = true;
            current_arg += 1;
       } else if (std::string("-l").compare(argv[current_arg]) == 0) {
            lexer_debug = true;
            current_arg += 1;
       } else if (std::string("-b").compare(argv[current_arg]) == 0) {
            parser_debug = true;
            lexer_debug = true;
            current_arg += 1;
       } else if (std::string("-f").compare(argv[current_arg]) == 0) {
            current_arg += 1;
            if (argc > current_arg) {
               input = std::string(argv[current_arg]);
               current_arg += 1;
               input_is_file = true;
            } else {
                std::cerr << "File name must be given for the -f option\n";
                exit(1);
            }
        } else if (std::string("-").compare(argv[current_arg]) == 0) {
           input_is_file = true;
           input = "-";
           current_arg += 1;
        } else {
            input = argv[current_arg];
            break;
        }
    }

    if (input.empty()) {
        std::cerr << "No input given\n";
        exit(1);
    }

    if (input_is_file) {
        if (input == "-") {
            std::ostringstream os;
            os << std::cin.rdbuf();
            input = os.str();
        } else {
            // slurp the entire file back into input
            //
            std::ifstream fstrm{input};
            if (fstrm) {
                std::ostringstream os;
                os << fstrm.rdbuf();
                input = os.str();
            } else {
                std::cerr << "Failed to open file '" << input << "'\n";
                exit(1);
            }
        }
    }

    YalrParser::Lexer lexer(input.cbegin(), input.cend());
    lexer.debug = lexer_debug;

    auto parser = YalrParser::Parser(lexer);
    parser.debug = parser_debug;

    if (parser.doparse()) {
        //std::cout << "Input matches grammar!\n";
        return 0;
    } else {
        std::cout << "Input does NOT match grammar\n";
        return 1;
    }
}
