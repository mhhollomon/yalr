#pragma once

#include "inja.hpp"
#include <string>

namespace yalr::codegen {

using namespace std::string_literals;

// Main file template
const std::string codegen_preamble =
R"DELIM(/* generated by <%header%> */
#include <iostream>
#include <vector>
#include <regex>
#include <algorithm>
#include <variant>
#include <string_view>
#include <tuple>
#include <set>

#define YALR_DEBUG

/***** verbatim file.top ********/
## for v in verbatim.file_top
<% v %>
## endfor
/***** verbatim file.top ********/

#if defined(YALR_DEBUG)
#  if ! defined(YALR_LDEBUG)
#    define YALR_LDEBUG(msg) { if (debug) \
    std::cerr << msg ; }
#  endif
#  if ! defined(YALR_PDEBUG)
#    define YALR_PDEBUG(msg) { if (debug) \
    std::cerr << msg ; }
#  endif
#else
#  define YALR_LDEBUG(msg)
#  define YALR_PDEBUG(msg)
#endif

namespace <%namespace%> {

/***** verbatim namespace.top ********/
## for v in verbatim.namespace_top
<% v %>
## endfor
/***** verbatim namespace.top ********/

enum token_type {
## for entry in enums
    <%entry.name%> = <%entry.value%>,
## endfor
};

#if defined(YALR_DEBUG)
char const * const token_name[] = {
{% for entry in enums -%} {%- if entry.value >= 0 %}
    "<%entry.debugname%>",{%-endif%} {%- endfor %}
};
#endif

enum state_action { undefined, shift, reduce, accept, error };


using semantic_value = std::variant<
    std::monostate
## for t in types
    , <% t %>
## endfor
    >;

struct value_printer {
    std::ostream& strm;
    void operator()(const std::monostate& m) {
        strm << "(void)";
    }
    void operator()(const std::string& s) {
        strm << "'" << s << "'";
    }

    template<typename T>
    void operator()(const T & t) {
        strm << t;
    }
};

struct token {
    token_type t;
    semantic_value v;

    token() {}
    token(token_type tt) : t{tt} {};
    token(token_type tt, semantic_value sv) : t{tt}, v{sv} {};
};

std::ostream& operator<<(std::ostream& strm, token t) {
#if defined(YALR_DEBUG) 
    strm << "{t=(" << t.t << "," << (t.t > -1 ? token_name[t.t] : "undef") << ") v=";
#else
    strm << "{t=" << t.t <<" v=";
#endif
    value_printer vp{strm};
    std::visit(vp, t.v);
    strm << "}";

    return strm;
}

} // namespace
)DELIM"s;



} // namespace yalr::codegen
