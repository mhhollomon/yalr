verbatim file.top <%{
#include <map>
}%>

verbatim namespace.top <%{
std::map<std::string, float> variables;
}%>

skip WS      r:\s+     ;

// basically here so that it is prefered to VARAIBLE
term PRINT 'print' ;

//
// zero to many underbar followed by a letter followed by as many digits,
// letters, underbars you want.
// allowed __a___
// not allowed __3
//
term <std::string> VARIABLE r:_*[a-zA-Z][_a-zA-Z0-9]* <%{ return std::move(lexeme); }%>

term<float> NUMBER r:-?\d*\.?\d+([eE][-+]?\d+)? <%{ return atof(lexeme.data()); }%>
term PLUS '+'  @assoc=left @prec=100 ;
term MINUS '-' @assoc=left @prec=PLUS ;
term MULTI '*' @assoc=left @prec=200 ;
term DIV   '/' @assoc=left @prec='*' ;

goal rule statement_list {
    => statement;
    => statement statement_list ;
}

rule statement { 
    => expression <%{ std::cout << "(e)answer = " << _v1 << "\n"; }%> 
    => 'print' expression <%{ std::cout << "(p)answer = " << _v2 << "\n"; }%> 
    => VARIABLE ':=' expression @prec=50 <%{
        std::cout << "assigning " << _v3 << " to '" << _v1 << "'\n"; 
        variables[_v1] = _v3;
    }%>

}

rule <float> expression {
    => l:expression '+' r:expression <%{ return l + r; }%>
    => l:expression '-' r:expression <%{ return l - r; }%>
    => l:expression '*' r:expression <%{ return l * r; }%>
    => l:expression '/' r:expression <%{ return l / r; }%>
    => NUMBER             <%{ return _v1; }%>
    => VARIABLE           <%{ return variables[_v1]; }%>
    => '(' expression ')' <%{ return _v2; }%>
}
